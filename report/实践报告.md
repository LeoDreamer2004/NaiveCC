# 编译原理课程实践报告：Naive Compiler

数学科学学院 原梓轩 2200010825

## 一、编译器概述

### 1.1 基本功能

本编译器基于 Rust 语言编写，具备如下功能：

1. 将SysY语言（一种 C 语言子集）进行语法分析，生成抽象语法树。
2. 将抽象语法树转换为 Koopa IR （一种简化版本的 LLVM IR）。
3. 将 Koopa IR 转换为 RISC-V 汇编代码。

### 1.2 主要特点

本编译器的主要特点是：

- 基于 Rust：Rust 语言具有内存安全的特性，适合编写高性能的系统级程序。
- 前后端分离：前端负责将源代码转换为 IR，后端负责将 IR 转换为汇编代码，实现代码的分层设计和解耦。
- 优化器包装：所有的优化器都实现 `optimizer` Trait 中，方便后续的扩展和维护。

## 二、编译器设计

### 2.1 主要模块组成

编译器由 3 个主要模块组成：

- 词法分析和语法分析：基于 `lalrpop` 第三方库，通过便捷的 BNF 定义自动将文件解析成抽象语法树。
- 中间代码生成（前端）：递归读取抽象语法树的内容，并生成 Koopa IR，并完成一些简单的优化。
- 目标代码生成（后端）：利用前端生成的中间代码，将其翻译成汇编代码，并做好栈帧分配和寄存器分配。

### 2.2 主要数据结构

#### 词法分析和语法分析

通过正则表达式，`lalrpop` 可以为我们自动辨别 `Identifier`, `i32` 以及注释等等词法分析的有关内容。

```rust
Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();
```

如果将一个 SysY 程序视作一棵树，那么一个 `CompUnit` 的实例就是这棵树的根，根据这一情况设计了一棵树状数据结构，例如如下的定义表明了整个程序由若干函数和变量声明组成：

```rust
pub struct CompUnit {
    pub comp_items: Vec<CompItem>,
}

pub enum CompItem {
    FuncDef(FuncDef),
    Decl(Decl),
}
```

`lalrpop` 为我们提供了方便的语法分析系统。它可以通过自动在 `target` 中生成一批代码，按照类似于 `match` 的匹配机制，让我们在读取源文件时就可以用 Rust 代码完成数据结构匹配和关联。

```rust
CompItem: CompItem = {
    <Decl> => CompItem::Decl(<>),
    <FuncDef> => CompItem::FuncDef(<>)
}
```

#### 中间代码生成

在前端，我定义了一个 `GenerateIr` 的 Trait，其中的 `generate_on` 方法可以将抽象语法树转换为 Koopa IR。用编译的思想看，这也是一种自顶向下的设计。`Environment` 结构体用于存储当前生成 IR 的环境，包括当前的函数、当前的基本块、符号表等等。

在 AST 定义之后，我们利用 Rust 的 `match` 语法，将 AST 中的每一个节点转换为 Koopa IR 中的一个节点。关于其他的辅助性结构，参看 2.3 节。

`koopa IR` 为我们提供了一个优化器的接口 `PassManager`，用于遍历所有的优化器。一般来说，优化器相当于一个“黑盒”，保证正确的程序输入，输出一个正确的优化的 IR 即可。

```rust
impl FunctionPass for MyOptimizer {
    fn run_on(&mut self, func: Function, data: &mut FunctionData) {
        // Optimize code here
    }
}
```

#### 目标代码生成

和中间代码生成类似，我们也定义了 `EntityAsmGenerator` 和 `ValueAsmGenerator` 的 Trait，用于将 IR 转换为汇编代码。前者用于处理 `Program`, `FunctionData` 和 `ValueData`，后者用于处理大批量的 `ValueKind`。也定义了 `Environment` 结构体，用于存储当前生成汇编代码的环境。

`Generator` 主要处理高层抽象，对于更加底层的与内存和寄存器的映射与交互，我定义了 `AsmManager` 来做统一的管理。更具体地，对于在前端定义的 `ValueData`，管理器会以对它的常量指针 (`*const ValueData`) 为键，在表中将它映射到如下位置之一：

``` rust
pub enum Location {
    /// The data is in the register.
    Register(Register),
    /// The data is in the stack.
    Stack(Stack),
    /// The data is in the data section.
    Data(Data),
}
```

以此将 IR 中的数据映射到汇编代码中的寄存器、栈和数据段中，从而实现对数据的加载与存储。

和前端类似, 后端的优化也是基于 `OptimizeManager` 的, 以此遍历所有优化器.

### 2.3 主要设计考虑及算法选择

#### 2.3.1 寄存器分配策略

我的寄存器分配采用的是 **图着色的全局寄存器分配** 算法。在这个算法中，我们首先通过后端操作，先假设寄存器有无穷个，将后端分配成 “伪寄存器” (`FakeRegister`) 的形式，类似于：

```riscv
li  reg_0 1
mv  reg_1 reg_0
add reg_2 reg_1 reg_0
```

我们首先做数据流分析 (`dataflow.rs`)，构建后端基本块的数据流图 `GlobalFlowGraph`。之后，构建一个结构体进行活跃变量分析 `LiveVariableAnalyser`，利用数据流方程迭代算法，找到每个寄存器的跨块活跃区间，即 in[B] 和 out[B]。

现在，转回寄存器分配 (`assign.rs`)，将所有的伪寄存器视为图中的节点，逐个扫描每一个块，以 out[B] 为基础，倒序遍历每一条指令，同步记录每条指令的活跃寄存器。如果两个变量同时活跃，那么它们之间就有一条边，以此构建寄存器冲突图 `RegisterInterferenceGraph`。

我们利用了 `heuristic_graph_coloring` crate 来帮助更高效地实现图着色，利用 RLF 算法，尽可能减少颜色的个数。如果颜色个数超过了寄存器的个数，那么我们就会将这个寄存器内容溢出到栈上。`MemoryAllocator` 负责这一部分工作。注意，由于溢出到栈上之后依然会需要读取到寄存器，所以我们进行重新分配，以此循环保证所有的变量都能被正确地分配。例如

```plaintext
reg_0 -> t0
reg_1 -> t1
reg_2 -> t1
```

最后，建立好对应关系之后，我们重写汇编代码，将伪寄存器替换为真实的寄存器或栈上的位置。 `RegisterRewriter` 负责这一部分工作。同时注意，遇到过程调用和跳转操作时，我们可能需要保存和恢复寄存器的内容，以此保证寄存器的正确性。

```riscv
li  t0 1
mv  t1 t0
add t1 t1 t0
```

复杂的优化换来的是更高的性能。这样的寄存器分配在测试时被证明是正确的，也是高效的。

#### 2.3.2 采用的优化策略

为了提高编译器的性能，我实现了从简到繁相当多的优化策略。

- **窥孔优化**

主要出现在后端。例如，如果连续出现 `Sw a, 0(sp)` 和 `Lw a, 0(sp)`，那么可以删去第二次操作。如果出现 `Li a, 5` 和 `Add c, a, b`，那么可以直接将第二条换成 `Addi c, b, 5`（虽然没有减少指令，但可能利用死代码消除删去第一条）。如果连续两条指令的目标寄存器相同，那么第一条指令就没有作用。

- **强度削弱**

主要出现在后端。利用右移和左移操作替代除法和乘法。

- **常量传播**

主要出现在前端。有一些值在编译时就可以确定，例如

```cpp
int a = 1;
int b = a + 1;
```

首先可以常量传播，把 `b` 优化为 `1 + 1`，随后可以进一步优化为 `2`。

- **控制流优化**

- **复制传播**

- **死代码消除和只读代码消除**

- **公共子表达式消除**

#### 2.3.3 其它补充设计考虑

谈谈做了哪些设计上的考虑，不超过200字，没有的话就不用写。

## 三、编译器实现

### 3.1 各阶段编码细节

介绍各阶段实现的时候自己认为有价值的信息，本部分内容**不做特别要求和限制**。可按如下所示的各阶段组织。

#### Lv1. main函数和Lv2. 初试目标代码生成

```
这部分虽然简单，但也可以讲两句。
```

#### Lv3. 表达式

```
有感触就说点啥，例如优先级。
```

#### Lv4. 常量和变量

```
总会有点想说的，因为多了变量。
```

#### Lv5. 语句块和作用域

```
作用域嵌套就没有可以分享的地方么？
```

#### Lv6. if语句

```
关于二义性问题是不是能在这里讨论一下。
```

#### Lv7. while语句

```
循环嵌套和控制流，总会有点想说的吧？
```

#### Lv8. 函数和全局变量

```
传参和返回值的处理，有想分享的地方么？
```

#### Lv9. 数组

```
数组参数？多维数组？不过……如果没做到这个阶段就不用写了。
```

### 3.2 工具软件介绍（若未使用特殊软件或库，则本部分可略过）

1. `例如flex/bison`：（100字以内，说明利用这个工具/模块/库做了什么）
2. `例如libkoopa`：（同上）
3. `其它软件或库`：（同上）

### 3.3 测试情况说明（如果进行过额外的测试，可增加此部分内容）

简述如何构造用例，测出过哪些不一样的错误，怎么发现和解决的。为课程提供优质测试用例会获得bonus。

## 四、实习总结

请至少谈1点，多谈谈更好。有机会获得奶茶或咖啡一杯。可以考虑按下面的几点讨论。

### 4.1 收获和体会

### 4.2 学习过程中的难点，以及对实习过程和内容的建议

### 4.3 对老师讲解内容与方式的建议
