# 编译原理课程实践报告：NaiveCC

数学科学学院 原梓轩 2200010825

## 一、编译器概述

### 1.1 基本功能

本编译器名为 NaiveCC（即 Naive C Language Compiler），基于 Rust 语言编写，具备如下功能：

1. 将 SysY 语言（一种 C 语言子集）进行语法分析，生成抽象语法树。
2. 将抽象语法树转换为 Koopa IR （一种简化版本的 LLVM IR）。
3. 将 Koopa IR 转换为 RISC-V 汇编代码。

### 1.2 主要特点

本编译器的主要特点是：

- **基于 Rust**：Rust 语言具有内存安全的特性，适合编写高性能的系统级程序。
- **前后端分离**：前端负责将源代码转换为 IR，后端负责将 IR 转换为汇编代码，实现代码的分层设计和解耦。
- **高效**：编译器实现了图着色寄存器分配算法、引入窥孔优化、强度削弱、常量传播等优化策略，同时通过数据流分析进一步做了更深层的优化，提高了编译器的性能。截止目前 200s 以内的成绩居于榜首。

## 二、编译器设计

### 2.1 主要模块组成

编译器由 3 个主要模块组成：

- 词法分析和语法分析：基于 `lalrpop` 第三方库，通过便捷的 BNF 定义自动将文件解析成抽象语法树。
- 中间代码生成（前端）：递归读取抽象语法树的内容，并生成 Koopa IR，并完成一些重要的机器无关优化。
- 目标代码生成（后端）：利用前端生成的中间代码，将其翻译成汇编代码，并做好栈帧分配和寄存器分配，完成一些机器有关优化。

### 2.2 主要数据结构

#### 词法分析和语法分析

通过正则表达式，`lalrpop` 可以为我们自动辨别 `Identifier`, `i32` 以及注释等等词法分析的有关内容。

```rust
Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();
```

如果将一个 SysY 程序视作一棵树，那么一个 `CompUnit` 的实例就是这棵树的根，根据这一情况设计了一棵树状数据结构，例如如下的定义表明了整个程序由若干函数和变量声明组成：

```rust
pub struct CompUnit {
    pub comp_items: Vec<CompItem>,
}

pub enum CompItem {
    FuncDef(FuncDef),
    Decl(Decl),
}
```

`lalrpop` 为我们提供了方便的语法分析系统。它可以通过自动在 `target` 中生成一批代码，按照类似于 `match` 的匹配机制，让我们在读取源文件时就可以用 Rust 代码完成数据结构匹配和关联。

```rust
CompItem: CompItem = {
    <Decl> => CompItem::Decl(<>),
    <FuncDef> => CompItem::FuncDef(<>)
}
```

#### 中间代码生成

在前端，我定义了一个 `GenerateIr` 的 Trait，其中的 `generate_on` 方法可以将抽象语法树转换为 Koopa IR。用编译的思想看，这也是一种自顶向下的设计。`Environment` 结构体用于存储当前生成 IR 的环境，包括当前的函数、当前的基本块、符号表等等。

在 AST 定义之后，我们利用 Rust 的 `match` 语法，将 AST 中的每一个节点转换为 Koopa IR 中的一个节点。关于其他的辅助性结构，参看 2.3 节。

`koopa IR` 为我们提供了一个优化器的接口 `PassManager`，用于遍历所有的优化器。一般来说，优化器相当于一个“黑盒”，保证正确的程序输入，输出一个正确的优化的 IR 即可。

```rust
impl FunctionPass for MyOptimizer {
    fn run_on(&mut self, func: Function, data: &mut FunctionData) {
        // Optimize code here
    }
}
```

#### 目标代码生成

汇编项目的数据结构架构大概如下：

```plaintext
AsmProgram
    |-> AsmGlobal (函数/全局变量)
        |-> Label (标签)
        |-> Section (.text/.data)
        |-> AsmLocal (基本块)
            |-> Label (标签，若为.data则为空)
            |-> Insts (指令)
```

和中间代码生成类似，我们也定义了 `EntityAsmGenerator` 和 `ValueAsmGenerator` 的 Trait，用于将 IR 转换为汇编代码。前者用于处理 `Program`, `FunctionData` 和 `ValueData`，后者用于处理大批量的 `ValueKind`。也定义了 `Environment` 结构体，用于存储当前生成汇编代码的环境。

`Generator` 主要处理高层抽象，对于更加底层的地址描述符映射，我定义了 `DescriptorTable` 来做统一的管理。更具体地，对于在前端定义的 `ValueData`，管理器会以对它的常量指针 (`*const ValueData`) 为键，在表中将它映射到如下位置之一：

``` rust
pub enum Descriptor {
    /// The data is in the register.
    Register(Register),
    /// The data is in the stack.
    Stack(Stack),
    /// The data is in the data section.
    Data(Data),
}
```

以此将 IR 中的数据映射到汇编代码中的寄存器、栈和数据段中，从而实现对数据的加载与存储。

和前端类似, 后端的优化也是基于 `OptimizeManager` 的, 以此遍历所有优化器. 关于寄存器和优化策略，参看第 4节。

## 三、编译器实现

### 3.1 各阶段编码细节

#### Lv1. main 函数和 Lv2. 初试目标代码生成

注意 koopa 的要求是每个基本块的最后一条指令是跳转指令或者返回指令，且有且仅有一个。所以在一个作用域如果有多个 return 语句，实际上只有一个会被执行，后面的生成应当直接截断停止。

#### Lv3. 表达式

这部分的表达式都是可以直接计算出来的，我们要求表达式实现一个 `Eval` Trait，用于计算表达式的值：

```rust
pub trait Eval<T> {
    fn eval(&self, table: &SymbolTable) -> Result<T, AstError>;
}
```

泛型 `T` 表示表达式的类型，例如 `i32`。

#### Lv4. 常量和变量

关于常量，因为它们是不可变的，遇到它们可以直接内联常数进去。而变量则需要出现在符号表中，以便于后续的寄存器分配。

这里的变量，我们都用 `FakeRegister` 来表示，它是一个虚拟的寄存器，用于在后端进行寄存器分配 (具体见第 4 节)。返回值直接用 `a0`, 而不使用 `FakeRegister`。

#### Lv5. 语句块和作用域

由于 SysY 语言并没有闭包的概念，所以作用域的实现相对简单。我们只需要简单地把符号表的作用域压栈和弹栈即可。引入一个占位符 `ScopeSepartator`，用于标记作用域的开始。离开作用域时，我们可以通过不断弹出，直到遇到这个占位符为止。

#### Lv6. if 语句

在语法分析中 if 语句会有二义性，我们约定，else 总是匹配最近的 if。引入 `IfMatchStmt` 和 `IfOpenStmt` 的 token 来消除二义性：

```lalrpop
__IfMatchStmt: Stmt = {
    "if" "(" <cond: Cond> ")" <stmt: __IfMatchStmt> "else" <else_stmt: __IfMatchStmt> => ...
}

__IfOpenStmt: Stmt = {
    "if" "(" <cond: Cond> ")" <stmt: Stmt> => ...,
    "if" "(" <cond: Cond> ")" <stmt: __IfMatchStmt> "else" <else_stmt: __IfOpenStmt> => ...
}
```

#### Lv7. while 语句

while 语句的实现和 if 语句类似，只是在生成 IR 时，需要在循环体的最后加上一个跳转指令，以实现循环。

关于 `break` 和 `continue` 语句，我们可以保存当前的循环嵌套栈，来实现跳转。在生成到 `break` 时，我们还没有生成结束的块，因此我们在 `while` 循环前先生成一个占位符，用于之后的跳转。

```koopa
%b1:
    j   %b3     // 条件跳转
%b2:
    j   %b4     // break的占位符
%b3:
    ...         // while循环体
    j   %b1
%b4:
    ...         // break的跳转位置
```

尽管这样看来可能引入了一些冗余的块和跳转指令，但是在后端的优化中，我们会将这些冗余消除。

#### Lv8. 函数和全局变量

riscv 的函数调用约定是将参数放在 `a0` 到 `a7` 中，返回值放在 `a0` 中，更多的参数则放在栈中。因此我们在函数调用时，需要将参数放入这些寄存器中。

我们约定，函数的参数是一份原本数据的拷贝，而不是引用。所以在生成前段时，对于参数部分，我们需要专门的 `load` 和 `store` 来拷贝，当然这部分是可以改进的，在优化的复制传播中，我们有可能可以将这些拷贝消除。

需要注意，在 Call 调用之前，对于当前还在活跃的寄存器，需要把它们存入栈中，以便在函数调用结束后恢复。

函数调用可能会对短路求值产生影响，例如：

```c
int a = f() || g();
```

如果 `f()` 返回 `true`，那么 `g()` 就不会被调用。所以在生成 Or 和 And 表达式时需要额外注意。采取建立临时变量的方式，来存储 `f()` 的结果。

然而，如果所有的 or/and 运算都这样做，那么会引入大量的临时变量，这是性能损失。我们在生成时记录或运算有没有副作用，如果没有，那么就直接计算 or/and 值，不需要建立临时变量。

对于全局变量，我们需要将它们放在 `.data` 段中，其对应的地址描述符是 `Data`，包含变量的标签和偏移量。在访问和修改时，都要用 lw/sw 指令来进行。

#### Lv9. 数组

数组的参数传递是通过指针来实现的，也就是传入的是数组的首地址。

考虑到符号表分析要考虑全局/局部，变量/常量，单元素/数组，有八种不同的组合，生成代码过于冗长。因此我们对符号表项进行了抽象，定义了 `SymbolItem` 结构体，用于表示符号表中的一个条目，其内包含一个符号，要求实现 `Symbol` Trait。

```rust
pub enum SymbolItem {
    Var(VarSymbol), // 变量
    VarArray(VarArraySymbol), // 数组
    Const(ConstSymbol), // 常量
    ConstArray(ConstArraySymbol), // 常量数组
    FParamArray(FParamArraySymbol), // 函数参数数组
    ScopeSeparator, // 作用域分隔符
}
```

我们在 `Symbol` Trait 实现了一系列方法，例如获取是否是数组、对符号取索引等等，在 `generate` 中就可以直接调用这些方法。

### 3.2 工具软件介绍

1. `lalrpop`：Rust 语言的 LALR 语法分析器生成器，用于生成词法分析和语法分析的代码。
2. `koopa`：北大提供的中间代码生成器，用于生成 IR 代码。
3. `heuristic_graph_coloring`：一个简单的启发式图着色算法库，用于进行寄存器分配。

## 四、主要设计考虑及算法选择

### 4.1 寄存器分配策略

我的寄存器分配采用的是 **图着色的全局寄存器分配** 算法。在这个算法中，我们首先通过后端操作，先假设寄存器有无穷个，将后端分配成 “伪寄存器” (`FakeRegister`) 的形式，类似于：

```riscv
li  reg_0 1
mv  reg_1 reg_0
add reg_2 reg_1 reg_0
```

我们首先做数据流分析 (`dataflow.rs`)，构建后端基本块的数据流图 `GlobalFlowGraph`。之后，构建一个结构体进行活跃变量分析 `LiveVariableAnalyser`，利用数据流方程迭代算法，找到每个寄存器的跨块活跃区间，即 in[B] 和 out[B]。

现在，转回寄存器分配 (`assign.rs`)，将所有的伪寄存器视为图中的节点，逐个扫描每一个块，以 out[B] 为基础，倒序遍历每一条指令，同步记录每条指令的活跃寄存器。如果两个变量同时活跃，那么它们之间就有一条边，以此构建寄存器冲突图 `RegisterInterferenceGraph`。

我们利用了 `heuristic_graph_coloring` crate 来帮助更高效地实现图着色，利用 RLF 算法，尽可能减少颜色的个数。如果颜色个数超过了寄存器的个数，那么我们就会将这个寄存器内容溢出到栈上。`MemoryAllocator` 负责这一部分工作。注意，由于溢出到栈上之后依然会需要读取到寄存器，所以我们进行重新分配，以此循环保证所有的变量都能被正确地分配。例如

```plaintext
reg_0 -> t0
reg_1 -> t1
reg_2 -> t1
```

最后，建立好对应关系之后，我们重写汇编代码，将伪寄存器替换为真实的寄存器或栈上的位置。 `RegisterRewriter` 负责这一部分工作。同时注意，遇到过程调用和跳转操作时，我们可能需要保存和恢复寄存器的内容，以此保证寄存器的正确性。

```riscv
li  t0 1
mv  t1 t0
add t1 t1 t0
```

复杂的优化换来的是更高的性能。这样的寄存器分配在测试时被证明是正确的，也是高效的。

### 4.2 采用的优化策略

为了提高编译器的性能，我实现了从简到繁相当多的优化策略。

- **窥孔优化**

出现在后端。例如，如果连续出现 `Sw a, 0(sp)` 和 `Lw a, 0(sp)`，那么可以删去第二次操作。如果出现 `Li a, 5` 和 `Add c, a, b`，那么可以直接将第二条换成 `Addi c, b, 5`（虽然没有减少指令，但可能利用死代码消除删去第一条）。如果连续两条指令的目标寄存器相同，那么第一条指令就没有作用。

- **强度削弱**

出现在后端。我只完成了最简单的强度削弱：利用右移和左移操作替代除法和乘法。

- **常量传播**

出现在前端。有一些值在编译时就可以确定，例如

```cpp
int a = 1;
int b = a + 1;
```

首先可以常量传播，`a` 的值在这个阶段一定是 `1`，把 `b` 优化为 `1 + 1`，随后可以进一步优化为 `2`。

- **控制流优化**

前后端都出现。通过合并基本块，减少跳转指令的数量。

首先建立控制流图。对于一条跳转 `A -> B`，如果 `A` 的出度只有 `B`，同时 `B` 的入度只有 `A`，那么可以通过删除从 `A` 到 `B` 的跳转指令，将 `B` 合并到 `A` 中。

- **复制传播** [到达定值分析]

前后端都出现。以前端为例，我们希望尽可能减少 `load` 和 `store` 语句。如果一个变量的值被赋值给另一个变量，那么可以直接将后者替换为前者。例如：

```koopa
store   %1, a
load    %2, a
add     %3, %2, 1
load    %4, a
add     %5, %4, 1
mul     %6, %4, %5
```

完全可以优化为

```koopa
store   %1, a
add     %3, %1, 1
add     %5, %1, 1
mul     %6, %1, %5
```

也就是我们直接用 `%1` 替换了 `%2`。即使 `a` 后续又被修改，可以再次替换成另外一个 `Value`。

其实这就是 SSA (Single Static Assignment，单赋值形式) 的一个简单想法。但是 SSA 的主要困难在于分支语句可能会导致重写的冲突。于是我们引入数据流分析的 **到达定值 (Reach-Definite) 分析** ，来判断哪些值在当前基本块是未被定值的或被唯一定值的。

到达定值分析方程：

$$
\begin{aligned}
in[B] &= \bigcup_{P \in \text{pred}[B]} out[P] \\
out[B] &= gen[B] \cup (in[B] - kill[B])
\end{aligned}
$$

按照这个方程，我们可以迭代地计算出每个基本块的 `in` 和 `out` 集合。这样我们就可以在遍历每个基本块的时候，根据 `in` 集合来判断是否可以进行复制传播。

- **死代码消除** [活跃变量分析]

前后端都出现。一般来说，作为写代码的程序员并不会手动写出死代码。但是在编译器生成的代码中，由于各种优化策略，可能会出现一些没有用的代码。我们还考虑复制传播的例子：

```koopa
store   %1, a
add     %3, %1, 1
add     %5, %1, 1
mul     %6, %1, %5
```

如果后续没有用到 `a`，那么 `a` 就是只被写入，没有被读取的死代码。从而可以直接删去这条语句。

```koopa
add     %3, %1, 1
add     %5, %1, 1
mul     %6, %1, %5
```

更进一步地，这里也要考虑跨块使用的可能。我们可以通过数据流分析的 **活跃变量 (Live Variables) 分析** 来找到这些死代码，然后将其删除。

活跃变量分析方程：

$$
\begin{aligned}
in[B] &= use[B] \cup (out[B] - def[B]) \\
out[B] &= \bigcup_{S \in \text{succ}[B]} in[S]
\end{aligned}
$$

按照这个方程，我们可以迭代地计算出每个基本块的 `in` 和 `out` 集合。这样我们就可以在遍历每个基本块的时候，根据 `out` 集合，倒序遍历基本块指令来判断是否可以进行死代码消除。

- **公共子表达式消除** [可用表达式分析]

在前端出现。如果一个表达式在程序中多次出现，那么我们可以将这个表达式提取出来，只计算一次。我们还考虑死代码消除的例子：

```koopa
add     %3, %1, 1
add     %5, %1, 1
mul     %6, %1, %5
```

可以优化为

```koopa
add     %3, %1, 1
mul     %6, %1, %3
```

我们直接用 `%3` 替换了 `%5`，这样就减少了一次计算。公共子表达式消除的关键在于数据流分析的 **可用表达式 (Available Expressions) 分析**。

可用表达式分析方程：

$$
\begin{aligned}
in[B] &= \bigcap_{P \in \text{pred}[B]} out[P] \\
out[B] &= egen[B] \cup (in[B] - ekill[B])
\end{aligned}
$$

按照这个方程，我们可以迭代地计算出每个基本块的 `in` 和 `out` 集合。这样我们就可以在遍历每个基本块的时候，根据 `in` 集合来判断是否可以进行公共子表达式消除。

### 4.3 其它补充设计考虑

考虑到 `addi`/`lw`/`sw` 的数字只能是 12 位，但是在生成时没有考虑到这一点。因此，我在生成汇编代码时，对于超过 12 位的数字，会单独用一个优化器 (实际上并没有优化效果，只是可以遍历) 进行修正。例如：

```koopa
addi    t1, t1, 0x800
```

修正为

```koopa
li      t0, 0x800
add     t1, t1, t0
```

## 五、实习总结

### 5.1 收获和体会

在这次实习中，我学到了很多编译原理的知识，包括词法分析、语法分析、中间代码生成、目标代码生成、寄存器分配、优化等等。

纸上得来终觉浅，绝知此事要躬行。这是我第一次学习并直接使用 Rust 语言编写大型项目（逾 6000 行），我对 Rust 语言的所有权系统、生命周期、模式匹配等特性有了更深入的了解，初步体会了函数式编程的魅力。即使可能由于不熟悉，写出的代码不够符合 Rust 的风格，我也通过反复的重构，尽量保持了代码的可读性和可维护性。

为了更快地理解 koopa IR 的接口，我阅读了 koopa 的源代码，了解了其中的一些细节和示例，这是我能顺利完成前端工作的重要原因。在后端，由于一我开始对汇编目标数据结构设计不当，导致后期的维护和优化工作变得困难，这也是在设计时应该更加谨慎的地方。

一个有趣的事实是，这次实习成为了我转向使用 Linux 系统的契机。在 Windows 下，我的 Docker 遇到了很多问题不能正常工作，国庆期间我安装了 ArchLinux 双系统，这些问题都迎刃而解，自此，我已经把 Arch 作为日用系统。

### 5.2 难点

关于原本的 9 个阶段的实现，我个人觉得并没有过于困难的地方，更多是对编译原理的基础知识的应用和相对机械式的工作。由于提供了 autotest 的测试工具，可以很方便地测试每个阶段的正确性。

寄存器分配相当具有挑战性。图着色算法是一个 NP 完全问题，因此我们只能通过启发式算法来解决。尽管我引入了一个着色算法的库，但很多实现细节还是需要自己来完成。在这个过程中，我学到了很多关于图着色算法的知识，例如 RLF 算法、冲突图的构建、溢出到栈上的处理等等。

做优化的部分是对代码能力极大的考验，在原有的结构上（尤其是前端）进行删减修改远比添加要难得多，数据流分析更是要引入合理的数据结构和算法方式来实现。这一部分消耗了我相当多的时间，进行反复的试错与 debug。

值得一提的是，我也借此发现了 koopa IR 当中的一个 bug，准备在 GitHub 发 issue 时，发现两年前就有人提出了相同的问题 [#4](https://github.com/pku-minic/koopa/issues/4)，助教进行了修复，接纳了我发布在 crates.io 的请求 [#7](https://github.com/pku-minic/koopa/issues/7)，这让我对自己的代码质量有了一定的信心。

### 5.3 对老师讲解内容与方式的建议

**提高出勤率**。出于某些原因，平时课程同学的出勤率实在是有点低。我想可能需要老师在课程中加入一些更加有趣的内容，或者是更加直观的实例，来吸引同学们的注意力。另外，有关实验的部分都是 C++ 的实现，希望能加入一些 Rust 的内容。

**改善测试点**。部分测试点的用例过于简单，有的用例虽然内部进行了很多操作，最后却只返回了一个常数，这样的测试点对于我们的编译器来说并没有太大的意义（在 lvl9 的测试点中这种现象尤为明显）。这是一个需要改进的地方。

**更关注优化**。优化是编译器的灵魂，也是我们在实习中最有挑战性的部分。我更希望老师可以在实践基础部分提供好一个现有的框架，让我们可以在此基础上进行更多的优化工作。当然，这需要我们自己的努力，现在这样的软性要求也无可厚非。
