use super::instruction::*;
use super::register::{self, Register, RegisterDispatcher};
use super::util::AsmIdentify;
use koopa::ir::entities::ValueData;
use koopa::ir::{BinaryOp, Function, FunctionData, Program, Value, ValueKind};
use std::io::Write;

pub trait GenerateAsm<T> {
    fn generate_on(&self, context: &mut Context) -> Result<T, AsmError>;
}

pub struct Context<'a> {
    pub asm: AsmProgram,
    pub dispatcher: RegisterDispatcher,

    pub program: &'a Program,
    pub function: Option<Function>,
    pub value: Option<Value>,
}

macro_rules! func_data {
    ($context:expr) => {
        $context.program.func($context.function.unwrap())
    };
}

macro_rules! value_data {
    ($context:expr, $value:expr) => {
        func_data!($context).dfg().value($value)
    };
}

#[derive(Debug)]
pub enum AsmError {
    RegisterNotAssigned(Option<String>),
}

impl GenerateAsm<()> for Program {
    fn generate_on(&self, context: &mut Context) -> Result<(), AsmError> {
        context.asm.push(Inst::Directive(Directive::Text));
        context
            .asm
            .push(Inst::Directive(Directive::Globl("main".to_string())));
        for &func in self.func_layout() {
            context.function = Some(func);
            self.func(func).generate_on(context)?;
        }
        Ok(())
    }
}

impl GenerateAsm<()> for FunctionData {
    fn generate_on(&self, context: &mut Context) -> Result<(), AsmError> {
        context
            .asm
            .push(Inst::Label(self.original_ident().to_string()));
        for (&_, node) in self.layout().bbs() {
            for &inst in node.insts().keys() {
                context.value = Some(inst);
                self.dfg().value(inst).generate_on(context)?;
            }
        }
        Ok(())
    }
}

impl GenerateAsm<()> for ValueData {
    fn generate_on(&self, context: &mut Context) -> Result<(), AsmError> {
        match self.kind() {
            ValueKind::Integer(_) => {
                unreachable!("Integer value should be generated by ElementData")
            }
            ValueKind::Binary(binary) => {
                let rs1 = binary.lhs().into_element().generate_on(context)?;
                let rs2 = binary.rhs().into_element().generate_on(context)?;
                let rd = context.dispatcher.alloc();
                let insts = match binary.op() {
                    BinaryOp::Add => vec![Inst::Add(Add { rd, rs1, rs2 })],
                    BinaryOp::Sub => vec![Inst::Sub(Sub { rd, rs1, rs2 })],
                    BinaryOp::Mul => vec![Inst::Mul(Mul { rd, rs1, rs2 })],
                    BinaryOp::Div => vec![Inst::Div(Div { rd, rs1, rs2 })],
                    BinaryOp::Mod => vec![Inst::Rem(Rem { rd, rs1, rs2 })],
                    BinaryOp::Lt => vec![Inst::Slt(Slt { rd, rs1, rs2 })],
                    BinaryOp::Gt => vec![Inst::Sgt(Sgt { rd, rs1, rs2 })],
                    BinaryOp::And => vec![Inst::And(And { rd, rs1, rs2 })],
                    BinaryOp::Or => vec![Inst::Or(Or { rd, rs1, rs2 })],
                    BinaryOp::Xor => vec![Inst::Xor(Xor { rd, rs1, rs2 })],
                    BinaryOp::Shl => vec![Inst::Sll(Sll { rd, rs1, rs2 })],
                    BinaryOp::Shr => vec![Inst::Srl(Srl { rd, rs1, rs2 })],
                    BinaryOp::Sar => vec![Inst::Sra(Sra { rd, rs1, rs2 })],

                    BinaryOp::Eq => vec![
                        // a == b => (a ^ b) == 0
                        Inst::Xor(Xor { rd, rs1, rs2 }),
                        Inst::SeqZ(SeqZ { rd, rs: rd }),
                    ],
                    BinaryOp::NotEq => vec![
                        // a != b => (a ^ b) != 0
                        Inst::Xor(Xor { rd, rs1, rs2 }),
                        Inst::SneZ(SneZ { rd, rs: rd }),
                    ],
                    BinaryOp::Ge => vec![
                        // a >= b => (a < b) == 0
                        Inst::Slt(Slt { rd, rs1, rs2 }),
                        Inst::SeqZ(SeqZ { rd, rs: rd }),
                    ],
                    BinaryOp::Le => vec![
                        // a <= b => (a > b) == 0
                        Inst::Sgt(Sgt { rd, rs1, rs2 }),
                        Inst::SeqZ(SeqZ { rd, rs: rd }),
                    ],
                };
                context.asm.extend(insts);
                context.dispatcher.assign(self, rd);
                Ok(())
            }
            ValueKind::Return(ret) => {
                if let Some(value) = ret.value() {
                    let mv = Mv {
                        rd: &register::A0,
                        rs: value.into_element().generate_on(context)?,
                    };
                    context.asm.push(Inst::Mv(mv));
                    context.asm.push(Inst::Ret(Ret {}));
                }
                Ok(())
            }
            _ => unreachable!(),
        }
    }
}

/// Basic element in an instruction, including immediate value and register.
pub struct ElementData {
    pub value: Value,
}

pub trait IntoElement {
    fn into_element(self) -> ElementData;
}

impl IntoElement for Value {
    fn into_element(self) -> ElementData {
        ElementData {
            value: self.clone(),
        }
    }
}

impl GenerateAsm<&'static Register> for ElementData {
    fn generate_on(&self, context: &mut Context) -> Result<&'static Register, AsmError> {
        let data = value_data!(context, self.value);
        match value_data!(context, self.value).kind() {
            ValueKind::Integer(int) => {
                let rd = context.dispatcher.alloc();
                let imm = int.value();
                if imm == 0 {
                    // simple optimization for zero
                    return Ok(&register::ZERO);
                };

                context.asm.push(Inst::Li(Li { rd, imm }));
                context.dispatcher.assign(data, rd);
                Ok(rd)
            }
            _ => context.dispatcher.get_or_error(data),
        }
    }
}

pub fn build_asm(ir_program: Program) -> Result<AsmProgram, AsmError> {
    let program = AsmProgram::new();
    let mut context = Context {
        asm: program,
        dispatcher: RegisterDispatcher::default(),

        program: &ir_program,
        function: None,
        value: None,
    };
    ir_program.generate_on(&mut context)?;
    Ok(context.asm)
}

pub fn emit_asm(program: AsmProgram, mut output: impl Write) -> Result<(), std::io::Error> {
    for inst in program {
        writeln!(output, "{}", inst.dump()).unwrap();
    }
    Ok(())
}
